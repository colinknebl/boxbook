// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type Address {
  id: ID!
  street1: String
  street2: String
  street3: String
  city: String
  state: String
  country: String
  postCode: String
}

type AddressConnection {
  pageInfo: PageInfo!
  edges: [AddressEdge]!
  aggregate: AggregateAddress!
}

input AddressCreateInput {
  id: ID
  street1: String
  street2: String
  street3: String
  city: String
  state: String
  country: String
  postCode: String
}

input AddressCreateOneInput {
  create: AddressCreateInput
  connect: AddressWhereUniqueInput
}

type AddressEdge {
  node: Address!
  cursor: String!
}

enum AddressOrderByInput {
  id_ASC
  id_DESC
  street1_ASC
  street1_DESC
  street2_ASC
  street2_DESC
  street3_ASC
  street3_DESC
  city_ASC
  city_DESC
  state_ASC
  state_DESC
  country_ASC
  country_DESC
  postCode_ASC
  postCode_DESC
}

type AddressPreviousValues {
  id: ID!
  street1: String
  street2: String
  street3: String
  city: String
  state: String
  country: String
  postCode: String
}

type AddressSubscriptionPayload {
  mutation: MutationType!
  node: Address
  updatedFields: [String!]
  previousValues: AddressPreviousValues
}

input AddressSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddressWhereInput
  AND: [AddressSubscriptionWhereInput!]
}

input AddressUpdateDataInput {
  street1: String
  street2: String
  street3: String
  city: String
  state: String
  country: String
  postCode: String
}

input AddressUpdateInput {
  street1: String
  street2: String
  street3: String
  city: String
  state: String
  country: String
  postCode: String
}

input AddressUpdateManyMutationInput {
  street1: String
  street2: String
  street3: String
  city: String
  state: String
  country: String
  postCode: String
}

input AddressUpdateOneInput {
  create: AddressCreateInput
  update: AddressUpdateDataInput
  upsert: AddressUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: AddressWhereUniqueInput
}

input AddressUpsertNestedInput {
  update: AddressUpdateDataInput!
  create: AddressCreateInput!
}

input AddressWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  street1: String
  street1_not: String
  street1_in: [String!]
  street1_not_in: [String!]
  street1_lt: String
  street1_lte: String
  street1_gt: String
  street1_gte: String
  street1_contains: String
  street1_not_contains: String
  street1_starts_with: String
  street1_not_starts_with: String
  street1_ends_with: String
  street1_not_ends_with: String
  street2: String
  street2_not: String
  street2_in: [String!]
  street2_not_in: [String!]
  street2_lt: String
  street2_lte: String
  street2_gt: String
  street2_gte: String
  street2_contains: String
  street2_not_contains: String
  street2_starts_with: String
  street2_not_starts_with: String
  street2_ends_with: String
  street2_not_ends_with: String
  street3: String
  street3_not: String
  street3_in: [String!]
  street3_not_in: [String!]
  street3_lt: String
  street3_lte: String
  street3_gt: String
  street3_gte: String
  street3_contains: String
  street3_not_contains: String
  street3_starts_with: String
  street3_not_starts_with: String
  street3_ends_with: String
  street3_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  country: String
  country_not: String
  country_in: [String!]
  country_not_in: [String!]
  country_lt: String
  country_lte: String
  country_gt: String
  country_gte: String
  country_contains: String
  country_not_contains: String
  country_starts_with: String
  country_not_starts_with: String
  country_ends_with: String
  country_not_ends_with: String
  postCode: String
  postCode_not: String
  postCode_in: [String!]
  postCode_not_in: [String!]
  postCode_lt: String
  postCode_lte: String
  postCode_gt: String
  postCode_gte: String
  postCode_contains: String
  postCode_not_contains: String
  postCode_starts_with: String
  postCode_not_starts_with: String
  postCode_ends_with: String
  postCode_not_ends_with: String
  AND: [AddressWhereInput!]
}

input AddressWhereUniqueInput {
  id: ID
}

type AggregateAddress {
  count: Int!
}

type AggregateLift {
  count: Int!
}

type AggregateLoggedLift {
  count: Int!
}

type AggregateLoggedWorkout {
  count: Int!
}

type AggregateName {
  count: Int!
}

type AggregateOrganization {
  count: Int!
}

type AggregateOrgEvent {
  count: Int!
}

type AggregateOrgSettings {
  count: Int!
}

type AggregatePerson {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserLog {
  count: Int!
}

type AggregateUserSettings {
  count: Int!
}

type AggregateWorkout {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

enum EventTypes {
  CLASS
}

type Lift {
  id: ID!
  name: String
  history(where: LoggedLiftWhereInput, orderBy: LoggedLiftOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LoggedLift!]
  oneRepMax: LoggedLift
}

type LiftConnection {
  pageInfo: PageInfo!
  edges: [LiftEdge]!
  aggregate: AggregateLift!
}

input LiftCreateInput {
  id: ID
  name: String
  history: LoggedLiftCreateManyInput
  oneRepMax: LoggedLiftCreateOneInput
}

input LiftCreateManyInput {
  create: [LiftCreateInput!]
  connect: [LiftWhereUniqueInput!]
}

type LiftEdge {
  node: Lift!
  cursor: String!
}

enum LiftOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type LiftPreviousValues {
  id: ID!
  name: String
}

input LiftScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [LiftScalarWhereInput!]
  OR: [LiftScalarWhereInput!]
  NOT: [LiftScalarWhereInput!]
}

type LiftSubscriptionPayload {
  mutation: MutationType!
  node: Lift
  updatedFields: [String!]
  previousValues: LiftPreviousValues
}

input LiftSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LiftWhereInput
  AND: [LiftSubscriptionWhereInput!]
}

input LiftUpdateDataInput {
  name: String
  history: LoggedLiftUpdateManyInput
  oneRepMax: LoggedLiftUpdateOneInput
}

input LiftUpdateInput {
  name: String
  history: LoggedLiftUpdateManyInput
  oneRepMax: LoggedLiftUpdateOneInput
}

input LiftUpdateManyDataInput {
  name: String
}

input LiftUpdateManyInput {
  create: [LiftCreateInput!]
  update: [LiftUpdateWithWhereUniqueNestedInput!]
  upsert: [LiftUpsertWithWhereUniqueNestedInput!]
  delete: [LiftWhereUniqueInput!]
  connect: [LiftWhereUniqueInput!]
  set: [LiftWhereUniqueInput!]
  disconnect: [LiftWhereUniqueInput!]
  deleteMany: [LiftScalarWhereInput!]
  updateMany: [LiftUpdateManyWithWhereNestedInput!]
}

input LiftUpdateManyMutationInput {
  name: String
}

input LiftUpdateManyWithWhereNestedInput {
  where: LiftScalarWhereInput!
  data: LiftUpdateManyDataInput!
}

input LiftUpdateWithWhereUniqueNestedInput {
  where: LiftWhereUniqueInput!
  data: LiftUpdateDataInput!
}

input LiftUpsertWithWhereUniqueNestedInput {
  where: LiftWhereUniqueInput!
  update: LiftUpdateDataInput!
  create: LiftCreateInput!
}

input LiftWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  history_some: LoggedLiftWhereInput
  oneRepMax: LoggedLiftWhereInput
  AND: [LiftWhereInput!]
}

input LiftWhereUniqueInput {
  id: ID
}

type LoggedLift {
  id: ID!
  weight: Int!
  date: DateTime!
  reps: [Int!]!
  sets: Int!
  createdAt: DateTime!
}

type LoggedLiftConnection {
  pageInfo: PageInfo!
  edges: [LoggedLiftEdge]!
  aggregate: AggregateLoggedLift!
}

input LoggedLiftCreateInput {
  id: ID
  weight: Int!
  date: DateTime!
  reps: LoggedLiftCreaterepsInput
  sets: Int!
}

input LoggedLiftCreateManyInput {
  create: [LoggedLiftCreateInput!]
  connect: [LoggedLiftWhereUniqueInput!]
}

input LoggedLiftCreateOneInput {
  create: LoggedLiftCreateInput
  connect: LoggedLiftWhereUniqueInput
}

input LoggedLiftCreaterepsInput {
  set: [Int!]
}

type LoggedLiftEdge {
  node: LoggedLift!
  cursor: String!
}

enum LoggedLiftOrderByInput {
  id_ASC
  id_DESC
  weight_ASC
  weight_DESC
  date_ASC
  date_DESC
  sets_ASC
  sets_DESC
  createdAt_ASC
  createdAt_DESC
}

type LoggedLiftPreviousValues {
  id: ID!
  weight: Int!
  date: DateTime!
  reps: [Int!]!
  sets: Int!
  createdAt: DateTime!
}

input LoggedLiftScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  sets: Int
  sets_not: Int
  sets_in: [Int!]
  sets_not_in: [Int!]
  sets_lt: Int
  sets_lte: Int
  sets_gt: Int
  sets_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [LoggedLiftScalarWhereInput!]
  OR: [LoggedLiftScalarWhereInput!]
  NOT: [LoggedLiftScalarWhereInput!]
}

type LoggedLiftSubscriptionPayload {
  mutation: MutationType!
  node: LoggedLift
  updatedFields: [String!]
  previousValues: LoggedLiftPreviousValues
}

input LoggedLiftSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LoggedLiftWhereInput
  AND: [LoggedLiftSubscriptionWhereInput!]
}

input LoggedLiftUpdateDataInput {
  weight: Int
  date: DateTime
  reps: LoggedLiftUpdaterepsInput
  sets: Int
}

input LoggedLiftUpdateInput {
  weight: Int
  date: DateTime
  reps: LoggedLiftUpdaterepsInput
  sets: Int
}

input LoggedLiftUpdateManyDataInput {
  weight: Int
  date: DateTime
  reps: LoggedLiftUpdaterepsInput
  sets: Int
}

input LoggedLiftUpdateManyInput {
  create: [LoggedLiftCreateInput!]
  update: [LoggedLiftUpdateWithWhereUniqueNestedInput!]
  upsert: [LoggedLiftUpsertWithWhereUniqueNestedInput!]
  delete: [LoggedLiftWhereUniqueInput!]
  connect: [LoggedLiftWhereUniqueInput!]
  set: [LoggedLiftWhereUniqueInput!]
  disconnect: [LoggedLiftWhereUniqueInput!]
  deleteMany: [LoggedLiftScalarWhereInput!]
  updateMany: [LoggedLiftUpdateManyWithWhereNestedInput!]
}

input LoggedLiftUpdateManyMutationInput {
  weight: Int
  date: DateTime
  reps: LoggedLiftUpdaterepsInput
  sets: Int
}

input LoggedLiftUpdateManyWithWhereNestedInput {
  where: LoggedLiftScalarWhereInput!
  data: LoggedLiftUpdateManyDataInput!
}

input LoggedLiftUpdateOneInput {
  create: LoggedLiftCreateInput
  update: LoggedLiftUpdateDataInput
  upsert: LoggedLiftUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: LoggedLiftWhereUniqueInput
}

input LoggedLiftUpdaterepsInput {
  set: [Int!]
}

input LoggedLiftUpdateWithWhereUniqueNestedInput {
  where: LoggedLiftWhereUniqueInput!
  data: LoggedLiftUpdateDataInput!
}

input LoggedLiftUpsertNestedInput {
  update: LoggedLiftUpdateDataInput!
  create: LoggedLiftCreateInput!
}

input LoggedLiftUpsertWithWhereUniqueNestedInput {
  where: LoggedLiftWhereUniqueInput!
  update: LoggedLiftUpdateDataInput!
  create: LoggedLiftCreateInput!
}

input LoggedLiftWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  sets: Int
  sets_not: Int
  sets_in: [Int!]
  sets_not_in: [Int!]
  sets_lt: Int
  sets_lte: Int
  sets_gt: Int
  sets_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [LoggedLiftWhereInput!]
}

input LoggedLiftWhereUniqueInput {
  id: ID
}

type LoggedWorkout {
  id: ID!
  workout: Workout!
  score: String!
  scoreType: ScoreTypes
  createdAt: DateTime!
}

type LoggedWorkoutConnection {
  pageInfo: PageInfo!
  edges: [LoggedWorkoutEdge]!
  aggregate: AggregateLoggedWorkout!
}

input LoggedWorkoutCreateInput {
  id: ID
  workout: WorkoutCreateOneInput!
  score: String!
  scoreType: ScoreTypes
}

input LoggedWorkoutCreateManyInput {
  create: [LoggedWorkoutCreateInput!]
  connect: [LoggedWorkoutWhereUniqueInput!]
}

type LoggedWorkoutEdge {
  node: LoggedWorkout!
  cursor: String!
}

enum LoggedWorkoutOrderByInput {
  id_ASC
  id_DESC
  score_ASC
  score_DESC
  scoreType_ASC
  scoreType_DESC
  createdAt_ASC
  createdAt_DESC
}

type LoggedWorkoutPreviousValues {
  id: ID!
  score: String!
  scoreType: ScoreTypes
  createdAt: DateTime!
}

input LoggedWorkoutScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  score: String
  score_not: String
  score_in: [String!]
  score_not_in: [String!]
  score_lt: String
  score_lte: String
  score_gt: String
  score_gte: String
  score_contains: String
  score_not_contains: String
  score_starts_with: String
  score_not_starts_with: String
  score_ends_with: String
  score_not_ends_with: String
  scoreType: ScoreTypes
  scoreType_not: ScoreTypes
  scoreType_in: [ScoreTypes!]
  scoreType_not_in: [ScoreTypes!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [LoggedWorkoutScalarWhereInput!]
  OR: [LoggedWorkoutScalarWhereInput!]
  NOT: [LoggedWorkoutScalarWhereInput!]
}

type LoggedWorkoutSubscriptionPayload {
  mutation: MutationType!
  node: LoggedWorkout
  updatedFields: [String!]
  previousValues: LoggedWorkoutPreviousValues
}

input LoggedWorkoutSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LoggedWorkoutWhereInput
  AND: [LoggedWorkoutSubscriptionWhereInput!]
}

input LoggedWorkoutUpdateDataInput {
  workout: WorkoutUpdateOneRequiredInput
  score: String
  scoreType: ScoreTypes
}

input LoggedWorkoutUpdateInput {
  workout: WorkoutUpdateOneRequiredInput
  score: String
  scoreType: ScoreTypes
}

input LoggedWorkoutUpdateManyDataInput {
  score: String
  scoreType: ScoreTypes
}

input LoggedWorkoutUpdateManyInput {
  create: [LoggedWorkoutCreateInput!]
  update: [LoggedWorkoutUpdateWithWhereUniqueNestedInput!]
  upsert: [LoggedWorkoutUpsertWithWhereUniqueNestedInput!]
  delete: [LoggedWorkoutWhereUniqueInput!]
  connect: [LoggedWorkoutWhereUniqueInput!]
  set: [LoggedWorkoutWhereUniqueInput!]
  disconnect: [LoggedWorkoutWhereUniqueInput!]
  deleteMany: [LoggedWorkoutScalarWhereInput!]
  updateMany: [LoggedWorkoutUpdateManyWithWhereNestedInput!]
}

input LoggedWorkoutUpdateManyMutationInput {
  score: String
  scoreType: ScoreTypes
}

input LoggedWorkoutUpdateManyWithWhereNestedInput {
  where: LoggedWorkoutScalarWhereInput!
  data: LoggedWorkoutUpdateManyDataInput!
}

input LoggedWorkoutUpdateWithWhereUniqueNestedInput {
  where: LoggedWorkoutWhereUniqueInput!
  data: LoggedWorkoutUpdateDataInput!
}

input LoggedWorkoutUpsertWithWhereUniqueNestedInput {
  where: LoggedWorkoutWhereUniqueInput!
  update: LoggedWorkoutUpdateDataInput!
  create: LoggedWorkoutCreateInput!
}

input LoggedWorkoutWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  workout: WorkoutWhereInput
  score: String
  score_not: String
  score_in: [String!]
  score_not_in: [String!]
  score_lt: String
  score_lte: String
  score_gt: String
  score_gte: String
  score_contains: String
  score_not_contains: String
  score_starts_with: String
  score_not_starts_with: String
  score_ends_with: String
  score_not_ends_with: String
  scoreType: ScoreTypes
  scoreType_not: ScoreTypes
  scoreType_in: [ScoreTypes!]
  scoreType_not_in: [ScoreTypes!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [LoggedWorkoutWhereInput!]
}

input LoggedWorkoutWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createAddress(data: AddressCreateInput!): Address!
  updateAddress(data: AddressUpdateInput!, where: AddressWhereUniqueInput!): Address
  updateManyAddresses(data: AddressUpdateManyMutationInput!, where: AddressWhereInput): BatchPayload!
  upsertAddress(where: AddressWhereUniqueInput!, create: AddressCreateInput!, update: AddressUpdateInput!): Address!
  deleteAddress(where: AddressWhereUniqueInput!): Address
  deleteManyAddresses(where: AddressWhereInput): BatchPayload!
  createLift(data: LiftCreateInput!): Lift!
  updateLift(data: LiftUpdateInput!, where: LiftWhereUniqueInput!): Lift
  updateManyLifts(data: LiftUpdateManyMutationInput!, where: LiftWhereInput): BatchPayload!
  upsertLift(where: LiftWhereUniqueInput!, create: LiftCreateInput!, update: LiftUpdateInput!): Lift!
  deleteLift(where: LiftWhereUniqueInput!): Lift
  deleteManyLifts(where: LiftWhereInput): BatchPayload!
  createLoggedLift(data: LoggedLiftCreateInput!): LoggedLift!
  updateLoggedLift(data: LoggedLiftUpdateInput!, where: LoggedLiftWhereUniqueInput!): LoggedLift
  updateManyLoggedLifts(data: LoggedLiftUpdateManyMutationInput!, where: LoggedLiftWhereInput): BatchPayload!
  upsertLoggedLift(where: LoggedLiftWhereUniqueInput!, create: LoggedLiftCreateInput!, update: LoggedLiftUpdateInput!): LoggedLift!
  deleteLoggedLift(where: LoggedLiftWhereUniqueInput!): LoggedLift
  deleteManyLoggedLifts(where: LoggedLiftWhereInput): BatchPayload!
  createLoggedWorkout(data: LoggedWorkoutCreateInput!): LoggedWorkout!
  updateLoggedWorkout(data: LoggedWorkoutUpdateInput!, where: LoggedWorkoutWhereUniqueInput!): LoggedWorkout
  updateManyLoggedWorkouts(data: LoggedWorkoutUpdateManyMutationInput!, where: LoggedWorkoutWhereInput): BatchPayload!
  upsertLoggedWorkout(where: LoggedWorkoutWhereUniqueInput!, create: LoggedWorkoutCreateInput!, update: LoggedWorkoutUpdateInput!): LoggedWorkout!
  deleteLoggedWorkout(where: LoggedWorkoutWhereUniqueInput!): LoggedWorkout
  deleteManyLoggedWorkouts(where: LoggedWorkoutWhereInput): BatchPayload!
  createName(data: NameCreateInput!): Name!
  updateName(data: NameUpdateInput!, where: NameWhereUniqueInput!): Name
  updateManyNames(data: NameUpdateManyMutationInput!, where: NameWhereInput): BatchPayload!
  upsertName(where: NameWhereUniqueInput!, create: NameCreateInput!, update: NameUpdateInput!): Name!
  deleteName(where: NameWhereUniqueInput!): Name
  deleteManyNames(where: NameWhereInput): BatchPayload!
  createOrgEvent(data: OrgEventCreateInput!): OrgEvent!
  updateOrgEvent(data: OrgEventUpdateInput!, where: OrgEventWhereUniqueInput!): OrgEvent
  updateManyOrgEvents(data: OrgEventUpdateManyMutationInput!, where: OrgEventWhereInput): BatchPayload!
  upsertOrgEvent(where: OrgEventWhereUniqueInput!, create: OrgEventCreateInput!, update: OrgEventUpdateInput!): OrgEvent!
  deleteOrgEvent(where: OrgEventWhereUniqueInput!): OrgEvent
  deleteManyOrgEvents(where: OrgEventWhereInput): BatchPayload!
  createOrgSettings(data: OrgSettingsCreateInput!): OrgSettings!
  deleteOrgSettings(where: OrgSettingsWhereUniqueInput!): OrgSettings
  deleteManyOrgSettingses(where: OrgSettingsWhereInput): BatchPayload!
  createOrganization(data: OrganizationCreateInput!): Organization!
  updateOrganization(data: OrganizationUpdateInput!, where: OrganizationWhereUniqueInput!): Organization
  updateManyOrganizations(data: OrganizationUpdateManyMutationInput!, where: OrganizationWhereInput): BatchPayload!
  upsertOrganization(where: OrganizationWhereUniqueInput!, create: OrganizationCreateInput!, update: OrganizationUpdateInput!): Organization!
  deleteOrganization(where: OrganizationWhereUniqueInput!): Organization
  deleteManyOrganizations(where: OrganizationWhereInput): BatchPayload!
  createPerson(data: PersonCreateInput!): Person!
  updatePerson(data: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person
  updateManyPersons(data: PersonUpdateManyMutationInput!, where: PersonWhereInput): BatchPayload!
  upsertPerson(where: PersonWhereUniqueInput!, create: PersonCreateInput!, update: PersonUpdateInput!): Person!
  deletePerson(where: PersonWhereUniqueInput!): Person
  deleteManyPersons(where: PersonWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createUserLog(data: UserLogCreateInput!): UserLog!
  updateUserLog(data: UserLogUpdateInput!, where: UserLogWhereUniqueInput!): UserLog
  upsertUserLog(where: UserLogWhereUniqueInput!, create: UserLogCreateInput!, update: UserLogUpdateInput!): UserLog!
  deleteUserLog(where: UserLogWhereUniqueInput!): UserLog
  deleteManyUserLogs(where: UserLogWhereInput): BatchPayload!
  createUserSettings(data: UserSettingsCreateInput!): UserSettings!
  deleteUserSettings(where: UserSettingsWhereUniqueInput!): UserSettings
  deleteManyUserSettingses(where: UserSettingsWhereInput): BatchPayload!
  createWorkout(data: WorkoutCreateInput!): Workout!
  updateWorkout(data: WorkoutUpdateInput!, where: WorkoutWhereUniqueInput!): Workout
  updateManyWorkouts(data: WorkoutUpdateManyMutationInput!, where: WorkoutWhereInput): BatchPayload!
  upsertWorkout(where: WorkoutWhereUniqueInput!, create: WorkoutCreateInput!, update: WorkoutUpdateInput!): Workout!
  deleteWorkout(where: WorkoutWhereUniqueInput!): Workout
  deleteManyWorkouts(where: WorkoutWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type Name {
  id: ID!
  first: String!
  last: String!
}

type NameConnection {
  pageInfo: PageInfo!
  edges: [NameEdge]!
  aggregate: AggregateName!
}

input NameCreateInput {
  id: ID
  first: String!
  last: String!
}

input NameCreateOneInput {
  create: NameCreateInput
  connect: NameWhereUniqueInput
}

type NameEdge {
  node: Name!
  cursor: String!
}

enum NameOrderByInput {
  id_ASC
  id_DESC
  first_ASC
  first_DESC
  last_ASC
  last_DESC
}

type NamePreviousValues {
  id: ID!
  first: String!
  last: String!
}

type NameSubscriptionPayload {
  mutation: MutationType!
  node: Name
  updatedFields: [String!]
  previousValues: NamePreviousValues
}

input NameSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NameWhereInput
  AND: [NameSubscriptionWhereInput!]
}

input NameUpdateDataInput {
  first: String
  last: String
}

input NameUpdateInput {
  first: String
  last: String
}

input NameUpdateManyMutationInput {
  first: String
  last: String
}

input NameUpdateOneRequiredInput {
  create: NameCreateInput
  update: NameUpdateDataInput
  upsert: NameUpsertNestedInput
  connect: NameWhereUniqueInput
}

input NameUpsertNestedInput {
  update: NameUpdateDataInput!
  create: NameCreateInput!
}

input NameWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  first: String
  first_not: String
  first_in: [String!]
  first_not_in: [String!]
  first_lt: String
  first_lte: String
  first_gt: String
  first_gte: String
  first_contains: String
  first_not_contains: String
  first_starts_with: String
  first_not_starts_with: String
  first_ends_with: String
  first_not_ends_with: String
  last: String
  last_not: String
  last_in: [String!]
  last_not_in: [String!]
  last_lt: String
  last_lte: String
  last_gt: String
  last_gte: String
  last_contains: String
  last_not_contains: String
  last_starts_with: String
  last_not_starts_with: String
  last_ends_with: String
  last_not_ends_with: String
  AND: [NameWhereInput!]
}

input NameWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type Organization {
  id: ID!
  code: String!
  address: Address
  admins(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  director: Person!
  events(where: OrgEventWhereInput, orderBy: OrgEventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrgEvent!]
  image: String
  name: String!
  settings: OrgSettings
  createdAt: DateTime!
}

type OrganizationConnection {
  pageInfo: PageInfo!
  edges: [OrganizationEdge]!
  aggregate: AggregateOrganization!
}

input OrganizationCreateInput {
  id: ID
  code: String!
  address: AddressCreateOneInput
  admins: UserCreateManyWithoutOrganizationsInput
  director: PersonCreateOneInput!
  events: OrgEventCreateManyWithoutOrganizationInput
  image: String
  name: String!
  settings: OrgSettingsCreateOneInput
}

input OrganizationCreateManyWithoutAdminsInput {
  create: [OrganizationCreateWithoutAdminsInput!]
  connect: [OrganizationWhereUniqueInput!]
}

input OrganizationCreateOneWithoutEventsInput {
  create: OrganizationCreateWithoutEventsInput
  connect: OrganizationWhereUniqueInput
}

input OrganizationCreateWithoutAdminsInput {
  id: ID
  code: String!
  address: AddressCreateOneInput
  director: PersonCreateOneInput!
  events: OrgEventCreateManyWithoutOrganizationInput
  image: String
  name: String!
  settings: OrgSettingsCreateOneInput
}

input OrganizationCreateWithoutEventsInput {
  id: ID
  code: String!
  address: AddressCreateOneInput
  admins: UserCreateManyWithoutOrganizationsInput
  director: PersonCreateOneInput!
  image: String
  name: String!
  settings: OrgSettingsCreateOneInput
}

type OrganizationEdge {
  node: Organization!
  cursor: String!
}

enum OrganizationOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  image_ASC
  image_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
}

type OrganizationPreviousValues {
  id: ID!
  code: String!
  image: String
  name: String!
  createdAt: DateTime!
}

input OrganizationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [OrganizationScalarWhereInput!]
  OR: [OrganizationScalarWhereInput!]
  NOT: [OrganizationScalarWhereInput!]
}

type OrganizationSubscriptionPayload {
  mutation: MutationType!
  node: Organization
  updatedFields: [String!]
  previousValues: OrganizationPreviousValues
}

input OrganizationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrganizationWhereInput
  AND: [OrganizationSubscriptionWhereInput!]
}

input OrganizationUpdateInput {
  code: String
  address: AddressUpdateOneInput
  admins: UserUpdateManyWithoutOrganizationsInput
  director: PersonUpdateOneRequiredInput
  events: OrgEventUpdateManyWithoutOrganizationInput
  image: String
  name: String
  settings: OrgSettingsUpdateOneInput
}

input OrganizationUpdateManyDataInput {
  code: String
  image: String
  name: String
}

input OrganizationUpdateManyMutationInput {
  code: String
  image: String
  name: String
}

input OrganizationUpdateManyWithoutAdminsInput {
  create: [OrganizationCreateWithoutAdminsInput!]
  delete: [OrganizationWhereUniqueInput!]
  connect: [OrganizationWhereUniqueInput!]
  set: [OrganizationWhereUniqueInput!]
  disconnect: [OrganizationWhereUniqueInput!]
  update: [OrganizationUpdateWithWhereUniqueWithoutAdminsInput!]
  upsert: [OrganizationUpsertWithWhereUniqueWithoutAdminsInput!]
  deleteMany: [OrganizationScalarWhereInput!]
  updateMany: [OrganizationUpdateManyWithWhereNestedInput!]
}

input OrganizationUpdateManyWithWhereNestedInput {
  where: OrganizationScalarWhereInput!
  data: OrganizationUpdateManyDataInput!
}

input OrganizationUpdateOneRequiredWithoutEventsInput {
  create: OrganizationCreateWithoutEventsInput
  update: OrganizationUpdateWithoutEventsDataInput
  upsert: OrganizationUpsertWithoutEventsInput
  connect: OrganizationWhereUniqueInput
}

input OrganizationUpdateWithoutAdminsDataInput {
  code: String
  address: AddressUpdateOneInput
  director: PersonUpdateOneRequiredInput
  events: OrgEventUpdateManyWithoutOrganizationInput
  image: String
  name: String
  settings: OrgSettingsUpdateOneInput
}

input OrganizationUpdateWithoutEventsDataInput {
  code: String
  address: AddressUpdateOneInput
  admins: UserUpdateManyWithoutOrganizationsInput
  director: PersonUpdateOneRequiredInput
  image: String
  name: String
  settings: OrgSettingsUpdateOneInput
}

input OrganizationUpdateWithWhereUniqueWithoutAdminsInput {
  where: OrganizationWhereUniqueInput!
  data: OrganizationUpdateWithoutAdminsDataInput!
}

input OrganizationUpsertWithoutEventsInput {
  update: OrganizationUpdateWithoutEventsDataInput!
  create: OrganizationCreateWithoutEventsInput!
}

input OrganizationUpsertWithWhereUniqueWithoutAdminsInput {
  where: OrganizationWhereUniqueInput!
  update: OrganizationUpdateWithoutAdminsDataInput!
  create: OrganizationCreateWithoutAdminsInput!
}

input OrganizationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  address: AddressWhereInput
  admins_some: UserWhereInput
  director: PersonWhereInput
  events_some: OrgEventWhereInput
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  settings: OrgSettingsWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [OrganizationWhereInput!]
}

input OrganizationWhereUniqueInput {
  id: ID
  code: String
}

type OrgEvent {
  id: ID!
  name: String!
  attendees(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  coordinator: Person!
  date: DateTime!
  eventType: [EventTypes!]!
  hourDuration: Float!
  image: String
  organization: Organization!
  createdAt: DateTime!
}

type OrgEventConnection {
  pageInfo: PageInfo!
  edges: [OrgEventEdge]!
  aggregate: AggregateOrgEvent!
}

input OrgEventCreateeventTypeInput {
  set: [EventTypes!]
}

input OrgEventCreateInput {
  id: ID
  name: String!
  attendees: UserCreateManyWithoutReservedInput
  coordinator: PersonCreateOneInput!
  date: DateTime!
  eventType: OrgEventCreateeventTypeInput
  hourDuration: Float!
  image: String
  organization: OrganizationCreateOneWithoutEventsInput!
}

input OrgEventCreateManyWithoutAttendeesInput {
  create: [OrgEventCreateWithoutAttendeesInput!]
  connect: [OrgEventWhereUniqueInput!]
}

input OrgEventCreateManyWithoutOrganizationInput {
  create: [OrgEventCreateWithoutOrganizationInput!]
  connect: [OrgEventWhereUniqueInput!]
}

input OrgEventCreateWithoutAttendeesInput {
  id: ID
  name: String!
  coordinator: PersonCreateOneInput!
  date: DateTime!
  eventType: OrgEventCreateeventTypeInput
  hourDuration: Float!
  image: String
  organization: OrganizationCreateOneWithoutEventsInput!
}

input OrgEventCreateWithoutOrganizationInput {
  id: ID
  name: String!
  attendees: UserCreateManyWithoutReservedInput
  coordinator: PersonCreateOneInput!
  date: DateTime!
  eventType: OrgEventCreateeventTypeInput
  hourDuration: Float!
  image: String
}

type OrgEventEdge {
  node: OrgEvent!
  cursor: String!
}

enum OrgEventOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  date_ASC
  date_DESC
  hourDuration_ASC
  hourDuration_DESC
  image_ASC
  image_DESC
  createdAt_ASC
  createdAt_DESC
}

type OrgEventPreviousValues {
  id: ID!
  name: String!
  date: DateTime!
  eventType: [EventTypes!]!
  hourDuration: Float!
  image: String
  createdAt: DateTime!
}

input OrgEventScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  hourDuration: Float
  hourDuration_not: Float
  hourDuration_in: [Float!]
  hourDuration_not_in: [Float!]
  hourDuration_lt: Float
  hourDuration_lte: Float
  hourDuration_gt: Float
  hourDuration_gte: Float
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [OrgEventScalarWhereInput!]
  OR: [OrgEventScalarWhereInput!]
  NOT: [OrgEventScalarWhereInput!]
}

type OrgEventSubscriptionPayload {
  mutation: MutationType!
  node: OrgEvent
  updatedFields: [String!]
  previousValues: OrgEventPreviousValues
}

input OrgEventSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrgEventWhereInput
  AND: [OrgEventSubscriptionWhereInput!]
}

input OrgEventUpdateeventTypeInput {
  set: [EventTypes!]
}

input OrgEventUpdateInput {
  name: String
  attendees: UserUpdateManyWithoutReservedInput
  coordinator: PersonUpdateOneRequiredInput
  date: DateTime
  eventType: OrgEventUpdateeventTypeInput
  hourDuration: Float
  image: String
  organization: OrganizationUpdateOneRequiredWithoutEventsInput
}

input OrgEventUpdateManyDataInput {
  name: String
  date: DateTime
  eventType: OrgEventUpdateeventTypeInput
  hourDuration: Float
  image: String
}

input OrgEventUpdateManyMutationInput {
  name: String
  date: DateTime
  eventType: OrgEventUpdateeventTypeInput
  hourDuration: Float
  image: String
}

input OrgEventUpdateManyWithoutAttendeesInput {
  create: [OrgEventCreateWithoutAttendeesInput!]
  delete: [OrgEventWhereUniqueInput!]
  connect: [OrgEventWhereUniqueInput!]
  set: [OrgEventWhereUniqueInput!]
  disconnect: [OrgEventWhereUniqueInput!]
  update: [OrgEventUpdateWithWhereUniqueWithoutAttendeesInput!]
  upsert: [OrgEventUpsertWithWhereUniqueWithoutAttendeesInput!]
  deleteMany: [OrgEventScalarWhereInput!]
  updateMany: [OrgEventUpdateManyWithWhereNestedInput!]
}

input OrgEventUpdateManyWithoutOrganizationInput {
  create: [OrgEventCreateWithoutOrganizationInput!]
  delete: [OrgEventWhereUniqueInput!]
  connect: [OrgEventWhereUniqueInput!]
  set: [OrgEventWhereUniqueInput!]
  disconnect: [OrgEventWhereUniqueInput!]
  update: [OrgEventUpdateWithWhereUniqueWithoutOrganizationInput!]
  upsert: [OrgEventUpsertWithWhereUniqueWithoutOrganizationInput!]
  deleteMany: [OrgEventScalarWhereInput!]
  updateMany: [OrgEventUpdateManyWithWhereNestedInput!]
}

input OrgEventUpdateManyWithWhereNestedInput {
  where: OrgEventScalarWhereInput!
  data: OrgEventUpdateManyDataInput!
}

input OrgEventUpdateWithoutAttendeesDataInput {
  name: String
  coordinator: PersonUpdateOneRequiredInput
  date: DateTime
  eventType: OrgEventUpdateeventTypeInput
  hourDuration: Float
  image: String
  organization: OrganizationUpdateOneRequiredWithoutEventsInput
}

input OrgEventUpdateWithoutOrganizationDataInput {
  name: String
  attendees: UserUpdateManyWithoutReservedInput
  coordinator: PersonUpdateOneRequiredInput
  date: DateTime
  eventType: OrgEventUpdateeventTypeInput
  hourDuration: Float
  image: String
}

input OrgEventUpdateWithWhereUniqueWithoutAttendeesInput {
  where: OrgEventWhereUniqueInput!
  data: OrgEventUpdateWithoutAttendeesDataInput!
}

input OrgEventUpdateWithWhereUniqueWithoutOrganizationInput {
  where: OrgEventWhereUniqueInput!
  data: OrgEventUpdateWithoutOrganizationDataInput!
}

input OrgEventUpsertWithWhereUniqueWithoutAttendeesInput {
  where: OrgEventWhereUniqueInput!
  update: OrgEventUpdateWithoutAttendeesDataInput!
  create: OrgEventCreateWithoutAttendeesInput!
}

input OrgEventUpsertWithWhereUniqueWithoutOrganizationInput {
  where: OrgEventWhereUniqueInput!
  update: OrgEventUpdateWithoutOrganizationDataInput!
  create: OrgEventCreateWithoutOrganizationInput!
}

input OrgEventWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  attendees_some: UserWhereInput
  coordinator: PersonWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  hourDuration: Float
  hourDuration_not: Float
  hourDuration_in: [Float!]
  hourDuration_not_in: [Float!]
  hourDuration_lt: Float
  hourDuration_lte: Float
  hourDuration_gt: Float
  hourDuration_gte: Float
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  organization: OrganizationWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [OrgEventWhereInput!]
}

input OrgEventWhereUniqueInput {
  id: ID
}

type OrgSettings {
  id: ID!
}

type OrgSettingsConnection {
  pageInfo: PageInfo!
  edges: [OrgSettingsEdge]!
  aggregate: AggregateOrgSettings!
}

input OrgSettingsCreateInput {
  id: ID
}

input OrgSettingsCreateOneInput {
  create: OrgSettingsCreateInput
  connect: OrgSettingsWhereUniqueInput
}

type OrgSettingsEdge {
  node: OrgSettings!
  cursor: String!
}

enum OrgSettingsOrderByInput {
  id_ASC
  id_DESC
}

type OrgSettingsPreviousValues {
  id: ID!
}

type OrgSettingsSubscriptionPayload {
  mutation: MutationType!
  node: OrgSettings
  updatedFields: [String!]
  previousValues: OrgSettingsPreviousValues
}

input OrgSettingsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrgSettingsWhereInput
  AND: [OrgSettingsSubscriptionWhereInput!]
}

input OrgSettingsUpdateOneInput {
  create: OrgSettingsCreateInput
  delete: Boolean
  disconnect: Boolean
  connect: OrgSettingsWhereUniqueInput
}

input OrgSettingsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [OrgSettingsWhereInput!]
}

input OrgSettingsWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Person {
  id: ID!
  email: String!
  image: String
  name: Name!
  phone: String
  createdAt: DateTime!
}

type PersonConnection {
  pageInfo: PageInfo!
  edges: [PersonEdge]!
  aggregate: AggregatePerson!
}

input PersonCreateInput {
  id: ID
  email: String!
  image: String
  name: NameCreateOneInput!
  phone: String
}

input PersonCreateOneInput {
  create: PersonCreateInput
  connect: PersonWhereUniqueInput
}

type PersonEdge {
  node: Person!
  cursor: String!
}

enum PersonOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  image_ASC
  image_DESC
  phone_ASC
  phone_DESC
  createdAt_ASC
  createdAt_DESC
}

type PersonPreviousValues {
  id: ID!
  email: String!
  image: String
  phone: String
  createdAt: DateTime!
}

type PersonSubscriptionPayload {
  mutation: MutationType!
  node: Person
  updatedFields: [String!]
  previousValues: PersonPreviousValues
}

input PersonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PersonWhereInput
  AND: [PersonSubscriptionWhereInput!]
}

input PersonUpdateDataInput {
  email: String
  image: String
  name: NameUpdateOneRequiredInput
  phone: String
}

input PersonUpdateInput {
  email: String
  image: String
  name: NameUpdateOneRequiredInput
  phone: String
}

input PersonUpdateManyMutationInput {
  email: String
  image: String
  phone: String
}

input PersonUpdateOneRequiredInput {
  create: PersonCreateInput
  update: PersonUpdateDataInput
  upsert: PersonUpsertNestedInput
  connect: PersonWhereUniqueInput
}

input PersonUpsertNestedInput {
  update: PersonUpdateDataInput!
  create: PersonCreateInput!
}

input PersonWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  name: NameWhereInput
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [PersonWhereInput!]
}

input PersonWhereUniqueInput {
  id: ID
  email: String
}

type Query {
  address(where: AddressWhereUniqueInput!): Address
  addresses(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Address]!
  addressesConnection(where: AddressWhereInput, orderBy: AddressOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressConnection!
  lift(where: LiftWhereUniqueInput!): Lift
  lifts(where: LiftWhereInput, orderBy: LiftOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Lift]!
  liftsConnection(where: LiftWhereInput, orderBy: LiftOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LiftConnection!
  loggedLift(where: LoggedLiftWhereUniqueInput!): LoggedLift
  loggedLifts(where: LoggedLiftWhereInput, orderBy: LoggedLiftOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LoggedLift]!
  loggedLiftsConnection(where: LoggedLiftWhereInput, orderBy: LoggedLiftOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LoggedLiftConnection!
  loggedWorkout(where: LoggedWorkoutWhereUniqueInput!): LoggedWorkout
  loggedWorkouts(where: LoggedWorkoutWhereInput, orderBy: LoggedWorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LoggedWorkout]!
  loggedWorkoutsConnection(where: LoggedWorkoutWhereInput, orderBy: LoggedWorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LoggedWorkoutConnection!
  name(where: NameWhereUniqueInput!): Name
  names(where: NameWhereInput, orderBy: NameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Name]!
  namesConnection(where: NameWhereInput, orderBy: NameOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NameConnection!
  orgEvent(where: OrgEventWhereUniqueInput!): OrgEvent
  orgEvents(where: OrgEventWhereInput, orderBy: OrgEventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrgEvent]!
  orgEventsConnection(where: OrgEventWhereInput, orderBy: OrgEventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrgEventConnection!
  orgSettings(where: OrgSettingsWhereUniqueInput!): OrgSettings
  orgSettingses(where: OrgSettingsWhereInput, orderBy: OrgSettingsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrgSettings]!
  orgSettingsesConnection(where: OrgSettingsWhereInput, orderBy: OrgSettingsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrgSettingsConnection!
  organization(where: OrganizationWhereUniqueInput!): Organization
  organizations(where: OrganizationWhereInput, orderBy: OrganizationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Organization]!
  organizationsConnection(where: OrganizationWhereInput, orderBy: OrganizationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrganizationConnection!
  person(where: PersonWhereUniqueInput!): Person
  persons(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Person]!
  personsConnection(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PersonConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  userLog(where: UserLogWhereUniqueInput!): UserLog
  userLogs(where: UserLogWhereInput, orderBy: UserLogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserLog]!
  userLogsConnection(where: UserLogWhereInput, orderBy: UserLogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserLogConnection!
  userSettings(where: UserSettingsWhereUniqueInput!): UserSettings
  userSettingses(where: UserSettingsWhereInput, orderBy: UserSettingsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserSettings]!
  userSettingsesConnection(where: UserSettingsWhereInput, orderBy: UserSettingsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserSettingsConnection!
  workout(where: WorkoutWhereUniqueInput!): Workout
  workouts(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workout]!
  workoutsConnection(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkoutConnection!
  node(id: ID!): Node
}

enum ScoreTypes {
  TIME
  REPS
  ROUNDS_TIME
  ROUNDS_REPS
}

type Subscription {
  address(where: AddressSubscriptionWhereInput): AddressSubscriptionPayload
  lift(where: LiftSubscriptionWhereInput): LiftSubscriptionPayload
  loggedLift(where: LoggedLiftSubscriptionWhereInput): LoggedLiftSubscriptionPayload
  loggedWorkout(where: LoggedWorkoutSubscriptionWhereInput): LoggedWorkoutSubscriptionPayload
  name(where: NameSubscriptionWhereInput): NameSubscriptionPayload
  orgEvent(where: OrgEventSubscriptionWhereInput): OrgEventSubscriptionPayload
  orgSettings(where: OrgSettingsSubscriptionWhereInput): OrgSettingsSubscriptionPayload
  organization(where: OrganizationSubscriptionWhereInput): OrganizationSubscriptionPayload
  person(where: PersonSubscriptionWhereInput): PersonSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  userLog(where: UserLogSubscriptionWhereInput): UserLogSubscriptionPayload
  userSettings(where: UserSettingsSubscriptionWhereInput): UserSettingsSubscriptionPayload
  workout(where: WorkoutSubscriptionWhereInput): WorkoutSubscriptionPayload
}

type User {
  id: ID!
  name: Name!
  email: String!
  phone: String
  image: String
  username: String!
  password: String!
  reserved(where: OrgEventWhereInput, orderBy: OrgEventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrgEvent!]
  organizations(where: OrganizationWhereInput, orderBy: OrganizationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Organization!]
  postCode: String
  settings: UserSettings
  isAdmin: Boolean
  friends(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  log: UserLog!
  createdAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: NameCreateOneInput!
  email: String!
  phone: String
  image: String
  username: String!
  password: String!
  reserved: OrgEventCreateManyWithoutAttendeesInput
  organizations: OrganizationCreateManyWithoutAdminsInput
  postCode: String
  settings: UserSettingsCreateOneInput
  isAdmin: Boolean
  friends: UserCreateManyInput
  log: UserLogCreateOneInput!
}

input UserCreateManyInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutOrganizationsInput {
  create: [UserCreateWithoutOrganizationsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutReservedInput {
  create: [UserCreateWithoutReservedInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateWithoutOrganizationsInput {
  id: ID
  name: NameCreateOneInput!
  email: String!
  phone: String
  image: String
  username: String!
  password: String!
  reserved: OrgEventCreateManyWithoutAttendeesInput
  postCode: String
  settings: UserSettingsCreateOneInput
  isAdmin: Boolean
  friends: UserCreateManyInput
  log: UserLogCreateOneInput!
}

input UserCreateWithoutReservedInput {
  id: ID
  name: NameCreateOneInput!
  email: String!
  phone: String
  image: String
  username: String!
  password: String!
  organizations: OrganizationCreateManyWithoutAdminsInput
  postCode: String
  settings: UserSettingsCreateOneInput
  isAdmin: Boolean
  friends: UserCreateManyInput
  log: UserLogCreateOneInput!
}

type UserEdge {
  node: User!
  cursor: String!
}

type UserLog {
  id: ID!
  lifts(where: LiftWhereInput, orderBy: LiftOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Lift!]
  workouts(where: LoggedWorkoutWhereInput, orderBy: LoggedWorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [LoggedWorkout!]
}

type UserLogConnection {
  pageInfo: PageInfo!
  edges: [UserLogEdge]!
  aggregate: AggregateUserLog!
}

input UserLogCreateInput {
  id: ID
  lifts: LiftCreateManyInput
  workouts: LoggedWorkoutCreateManyInput
}

input UserLogCreateOneInput {
  create: UserLogCreateInput
  connect: UserLogWhereUniqueInput
}

type UserLogEdge {
  node: UserLog!
  cursor: String!
}

enum UserLogOrderByInput {
  id_ASC
  id_DESC
}

type UserLogPreviousValues {
  id: ID!
}

type UserLogSubscriptionPayload {
  mutation: MutationType!
  node: UserLog
  updatedFields: [String!]
  previousValues: UserLogPreviousValues
}

input UserLogSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserLogWhereInput
  AND: [UserLogSubscriptionWhereInput!]
}

input UserLogUpdateDataInput {
  lifts: LiftUpdateManyInput
  workouts: LoggedWorkoutUpdateManyInput
}

input UserLogUpdateInput {
  lifts: LiftUpdateManyInput
  workouts: LoggedWorkoutUpdateManyInput
}

input UserLogUpdateOneRequiredInput {
  create: UserLogCreateInput
  update: UserLogUpdateDataInput
  upsert: UserLogUpsertNestedInput
  connect: UserLogWhereUniqueInput
}

input UserLogUpsertNestedInput {
  update: UserLogUpdateDataInput!
  create: UserLogCreateInput!
}

input UserLogWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  lifts_some: LiftWhereInput
  workouts_some: LoggedWorkoutWhereInput
  AND: [UserLogWhereInput!]
}

input UserLogWhereUniqueInput {
  id: ID
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  image_ASC
  image_DESC
  username_ASC
  username_DESC
  password_ASC
  password_DESC
  postCode_ASC
  postCode_DESC
  isAdmin_ASC
  isAdmin_DESC
  createdAt_ASC
  createdAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  phone: String
  image: String
  username: String!
  password: String!
  postCode: String
  isAdmin: Boolean
  createdAt: DateTime!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  postCode: String
  postCode_not: String
  postCode_in: [String!]
  postCode_not_in: [String!]
  postCode_lt: String
  postCode_lte: String
  postCode_gt: String
  postCode_gte: String
  postCode_contains: String
  postCode_not_contains: String
  postCode_starts_with: String
  postCode_not_starts_with: String
  postCode_ends_with: String
  postCode_not_ends_with: String
  isAdmin: Boolean
  isAdmin_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSettings {
  id: ID!
}

type UserSettingsConnection {
  pageInfo: PageInfo!
  edges: [UserSettingsEdge]!
  aggregate: AggregateUserSettings!
}

input UserSettingsCreateInput {
  id: ID
}

input UserSettingsCreateOneInput {
  create: UserSettingsCreateInput
  connect: UserSettingsWhereUniqueInput
}

type UserSettingsEdge {
  node: UserSettings!
  cursor: String!
}

enum UserSettingsOrderByInput {
  id_ASC
  id_DESC
}

type UserSettingsPreviousValues {
  id: ID!
}

type UserSettingsSubscriptionPayload {
  mutation: MutationType!
  node: UserSettings
  updatedFields: [String!]
  previousValues: UserSettingsPreviousValues
}

input UserSettingsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserSettingsWhereInput
  AND: [UserSettingsSubscriptionWhereInput!]
}

input UserSettingsUpdateOneInput {
  create: UserSettingsCreateInput
  delete: Boolean
  disconnect: Boolean
  connect: UserSettingsWhereUniqueInput
}

input UserSettingsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [UserSettingsWhereInput!]
}

input UserSettingsWhereUniqueInput {
  id: ID
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: NameUpdateOneRequiredInput
  email: String
  phone: String
  image: String
  username: String
  password: String
  reserved: OrgEventUpdateManyWithoutAttendeesInput
  organizations: OrganizationUpdateManyWithoutAdminsInput
  postCode: String
  settings: UserSettingsUpdateOneInput
  isAdmin: Boolean
  friends: UserUpdateManyInput
  log: UserLogUpdateOneRequiredInput
}

input UserUpdateInput {
  name: NameUpdateOneRequiredInput
  email: String
  phone: String
  image: String
  username: String
  password: String
  reserved: OrgEventUpdateManyWithoutAttendeesInput
  organizations: OrganizationUpdateManyWithoutAdminsInput
  postCode: String
  settings: UserSettingsUpdateOneInput
  isAdmin: Boolean
  friends: UserUpdateManyInput
  log: UserLogUpdateOneRequiredInput
}

input UserUpdateManyDataInput {
  email: String
  phone: String
  image: String
  username: String
  password: String
  postCode: String
  isAdmin: Boolean
}

input UserUpdateManyInput {
  create: [UserCreateInput!]
  update: [UserUpdateWithWhereUniqueNestedInput!]
  upsert: [UserUpsertWithWhereUniqueNestedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyMutationInput {
  email: String
  phone: String
  image: String
  username: String
  password: String
  postCode: String
  isAdmin: Boolean
}

input UserUpdateManyWithoutOrganizationsInput {
  create: [UserCreateWithoutOrganizationsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutOrganizationsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutOrganizationsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutReservedInput {
  create: [UserCreateWithoutReservedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutReservedInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutReservedInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateWithoutOrganizationsDataInput {
  name: NameUpdateOneRequiredInput
  email: String
  phone: String
  image: String
  username: String
  password: String
  reserved: OrgEventUpdateManyWithoutAttendeesInput
  postCode: String
  settings: UserSettingsUpdateOneInput
  isAdmin: Boolean
  friends: UserUpdateManyInput
  log: UserLogUpdateOneRequiredInput
}

input UserUpdateWithoutReservedDataInput {
  name: NameUpdateOneRequiredInput
  email: String
  phone: String
  image: String
  username: String
  password: String
  organizations: OrganizationUpdateManyWithoutAdminsInput
  postCode: String
  settings: UserSettingsUpdateOneInput
  isAdmin: Boolean
  friends: UserUpdateManyInput
  log: UserLogUpdateOneRequiredInput
}

input UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateDataInput!
}

input UserUpdateWithWhereUniqueWithoutOrganizationsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutOrganizationsDataInput!
}

input UserUpdateWithWhereUniqueWithoutReservedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutReservedDataInput!
}

input UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutOrganizationsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutOrganizationsDataInput!
  create: UserCreateWithoutOrganizationsInput!
}

input UserUpsertWithWhereUniqueWithoutReservedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutReservedDataInput!
  create: UserCreateWithoutReservedInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: NameWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  reserved_some: OrgEventWhereInput
  organizations_some: OrganizationWhereInput
  postCode: String
  postCode_not: String
  postCode_in: [String!]
  postCode_not_in: [String!]
  postCode_lt: String
  postCode_lte: String
  postCode_gt: String
  postCode_gte: String
  postCode_contains: String
  postCode_not_contains: String
  postCode_starts_with: String
  postCode_not_starts_with: String
  postCode_ends_with: String
  postCode_not_ends_with: String
  settings: UserSettingsWhereInput
  isAdmin: Boolean
  isAdmin_not: Boolean
  friends_some: UserWhereInput
  log: UserLogWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
  username: String
}

type Workout {
  id: ID!
  name: String!
  instructions: String!
  createdAt: DateTime!
}

type WorkoutConnection {
  pageInfo: PageInfo!
  edges: [WorkoutEdge]!
  aggregate: AggregateWorkout!
}

input WorkoutCreateInput {
  id: ID
  name: String!
  instructions: String!
}

input WorkoutCreateOneInput {
  create: WorkoutCreateInput
  connect: WorkoutWhereUniqueInput
}

type WorkoutEdge {
  node: Workout!
  cursor: String!
}

enum WorkoutOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  instructions_ASC
  instructions_DESC
  createdAt_ASC
  createdAt_DESC
}

type WorkoutPreviousValues {
  id: ID!
  name: String!
  instructions: String!
  createdAt: DateTime!
}

type WorkoutSubscriptionPayload {
  mutation: MutationType!
  node: Workout
  updatedFields: [String!]
  previousValues: WorkoutPreviousValues
}

input WorkoutSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkoutWhereInput
  AND: [WorkoutSubscriptionWhereInput!]
}

input WorkoutUpdateDataInput {
  name: String
  instructions: String
}

input WorkoutUpdateInput {
  name: String
  instructions: String
}

input WorkoutUpdateManyMutationInput {
  name: String
  instructions: String
}

input WorkoutUpdateOneRequiredInput {
  create: WorkoutCreateInput
  update: WorkoutUpdateDataInput
  upsert: WorkoutUpsertNestedInput
  connect: WorkoutWhereUniqueInput
}

input WorkoutUpsertNestedInput {
  update: WorkoutUpdateDataInput!
  create: WorkoutCreateInput!
}

input WorkoutWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  instructions: String
  instructions_not: String
  instructions_in: [String!]
  instructions_not_in: [String!]
  instructions_lt: String
  instructions_lte: String
  instructions_gt: String
  instructions_gte: String
  instructions_contains: String
  instructions_not_contains: String
  instructions_starts_with: String
  instructions_not_starts_with: String
  instructions_ends_with: String
  instructions_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [WorkoutWhereInput!]
}

input WorkoutWhereUniqueInput {
  id: ID
}
`